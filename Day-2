https://leetcode.com/problems/product-of-array-except-self/description/

class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        int price = prices[0];
        for(int i : prices){
            price = Math.min(i,price);
            if(i-price>profit)
            profit = i-price;
        }
        return profit;
    }
}

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
      
 class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n  = nums.length;
        int zeroCount = 0;
        int totalProduct = 1;
        for(int num :nums) {
            if(num == 0){
                zeroCount++;
            }
            else{
                totalProduct *= num;
          }
        }
        for(int i = 0; i <n; i++){
            if(zeroCount == 1 && nums[i] == 0){
            nums[i] = totalProduct;
            }
            else if( zeroCount >= 1){ // 1 0 2 3 
                nums[i] = 0;
            }
            else {
                nums[i] = totalProduct/nums[i]; // 1 2 3 4 
            }
        }
      return nums;  
        
    }
    }

https://leetcode.com/problems/valid-palindrome/description/
class Solution {
    public static boolean ispalindrome(String s,int i,int j){
        if(i>=j){
            return true;
        }
        if(s.charAt(i)!=s.charAt(j)){
            return false;
        }
        return ispalindrome(s,i+1,j-1);
    }
    public boolean isPalindrome(String s) {
      String regex="[^a-zA-Z0-9]";
        String removedeverything=s.replaceAll(regex,"").toLowerCase();
    return ispalindrome(removedeverything,0,removedeverything.length()-1);

    }
   
}
